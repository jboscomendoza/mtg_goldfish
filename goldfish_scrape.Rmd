---
title: "MTG Goldfish"
author: "Juan Bosco Mendoza Vega"
date: "20 de agosto de 2018"
output: 
  html_document: 
    fig_height: 6
    fig_width: 7.5
    highlight: haddock
    number_sections: yes
    theme: yeti
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Para este análisis usaremos los datos del sitio MTG Goldfish.

Visita MTG Goldfish, es un sitio excelente.



Vamos a realizar este análisis en varios pasos:

* Descarga de los precios y procesamiento para análisis.
* Simulación de valores, por sobre abierto y por caja abierta.
* Cálculo de probabilidad de quedar tablas.
* Sistematización del análisis para poder ejecutarlo eficientemente de manera repetida.

# Paquetes necesarios
Para este proyecto usaremos los siguientes paquetes:

* **tidyverse**: Una familia de paquetes para importar, manipular, exportar y visualizar datos.
* **rvest**: Funciones para extraer información de páginas web (*scrapping*).
* **xml2**: Este paquete nos permite importar y manipular datos con estructuras xml.
* **scales**: Funciones para mejorar la presentación de datos en gráficos.
* **ggrepel**: Un paquete que expande las funciones de **ggplot2** (parte de *tidyverse*), para mostrar etiquetas sin sobreposiciones entre ellas.

```{r, message=FALSE}
library(tidyverse)
library(rvest)
library(xml2)
library(scales)
library(ggrepel)
```

Como es usual, puedes instalar estos paquetes usando la función `install.packages()`.

# Obtener la información de precios
En MTG Goldfish, La información de los precios de un set de MtG es presentada en su propia pagina, usando el código del set.

Los sets de MtG son identificados por un código de tres cracteres, en mayúsculas. Por ejemplo, para Dominaria, el código del set es "DOM", por lo que el URL en el que encontramos sus precios se ecuentran en:
 
 * https://www.mtggoldfish.com/index/DOM
 
Una lista de los códigos de sets de Magic se encuentra disponible en:

* https://mtg.gamepedia.com/Template:List_of_Magic_sets

Usamos `download_html()` para descargar una página de internet a nuestra carpeta de trabajo como "goldfish_DOM.html".
```{r descarga precios, eval = FALSE}
download_html(url = "https://www.mtggoldfish.com/index/DOM",
              file = "goldfish_DOM.html")
```

Podemos definir una función que nos permita descargar el html que corresponde a un set de manera más sencilla, proporcionando únicamente e código de tres letras de este. 
```{r def_descargar_set}
descargar_set <- function(clave) {
  mtg_url <- paste0("https://www.mtggoldfish.com/index/", clave)
  mtg_archivo <- paste0("goldfish_", clave, ".html")
  download_html(url = mtg_url, file = mtg_archivo)
}
```

Hecho esto, importamos el archivo con el html descargado y lo asignamos al objeto mtg_dom.
```{r importar_dom}
mtg_dom <- read_html("goldfish_DOM.html")
```

Si llamamos a este objeto, podremos ver que es un documento con estructura de xml.
```{r mtg_dom_xml}
mtg_dom
```

Con este formato no podemos hacer mucho. Necesitamos extraer los datos que contiene y para ello, usaremos las funciones del paquete **rvest**.

**rvest** extrae información de un documento que contiene html o xml usando los identificadores de **css**.

Como vamos a recuperar los datos de precios de las cartas, necesitamos los identificadores css de estos datos. Para obtenerlos hay distintas maneras, pero nosotros simplemente exploraremos la página original y daremos un vistazo a su código fuente.

Bueno, para este artículo ya he hecho esa tarea, así que veamos los resultados, usando la función `html_node()`.
```{r css_dom}
mtg_dom %>% 
  html_node(css = ".index-price-table-paper tbody tr")
```

Aún no es un formato útil para el análisis necesitamos la función `html_text()`. Esto nos devolverá una cantidad considerable de texto, asi que pediremos sólo las primeras líneas con `head()`.

```{r css_dom_text}
mtg_dom %>% 
  html_nodes(css = ".index-price-table-paper tbody tr") %>% 
  html_text() %>% 
  head()
```

Esto ya es más manejable. Usamos la función `str_split()` con `as.data.frame()` y `tbl_df()` para convertir estos datos a un data frame, que llamaremos df_dom

```{r css_dom_text_tbldf}
df_dom <- 
  mtg_dom %>% 
  html_nodes(css = ".index-price-table-paper tbody tr") %>% 
  html_text() %>% 
  str_split(pattern = "\\n", simplify = T) %>%
  as.data.frame() %>%
  tbl_df()
```

Veamos el resultado.
```{r}
df_dom
```

Tenemos que pulir un poco nuestro data frame, seleccionando sólo las columnas que nos interesan con `select()` de **dplyr**
```{r}
df_dom <- 
  df_dom %>% 
  select("Carta" = V1, "Set" = V2, "Rareza" = V3, "Precio" = V5) %>% 
  mutate(Precio = as.numeric(as.character(Precio)), 
         Rareza = factor(Rareza, levels = c("Basic Land","Common",
                                            "Uncommon", "Rare", "Mythic"))) %>% 
  mutate_at(c("Carta", "Set"), as.character) %>% 
  filter(Rareza != "Basic Land")
```

Veamos nuestro resultado.
```{r}
df_dom
```

Transformamos lo anterior en una función, llamada `leer_html()` para así generar fácilmente data frames a partir del html de páginas de **MTG Goldfish**.
```{r def_leer_html}
leer_html <- function(archivo_html) {
  archivo_html %>% 
    read_html() %>% 
    html_nodes(css = ".index-price-table-paper tbody tr") %>% 
    html_text() %>% 
    str_split(pattern = "\\n", simplify = T) %>%
    as.data.frame() %>%
    select("Carta" = V1, "Set" = V2, "Rareza" = V3, "Precio" = V5) %>%
    mutate(Precio = as.numeric(as.character(Precio)),
           Rareza = factor(Rareza, 
                           levels = c("Basic Land","Common", 
                                      "Uncommon", "Rare", "Mythic"))) %>% 
    mutate_at(c("Carta", "Set"), as.character) %>% 
    filter(Rareza != "Basic Land") %>% 
    tbl_df()
}
```

Ya casi estamos listos para continuar, pero antes tenemos que hacer una recodificación.

## Identificando *outliers*
Como nuestro interés en este proyecto es analizar el valor monetario de un set de Magic, nos conviene identificar aquellas cartas que tienen un valor excepcionalente alto, con respecto a las demás. 

Esto es, aquellas que son *outliers*.

En cuanto a *outliers* no hay concenso 

Nosotros usaremos como criterio el usando al generar gráficos de caja y bigote (*boxplot*), que es:

* Un dato menor a: el valor del primer cuartil menos una vez y media el rango intercuartílico.
* Un dato mayor a: el valor del tercer cuartil más una vez y media el rango intercuartílico.

Estos son los datos que se salen de los "bigotes" de un *boxplot* y son mostrados como puntos.

Sólo etiquetaremos los outliers "altos", pues estos son los relevantes para el análisis que haremos.

Podemos convertir el criterio anterior en una función:
```{r tag_outliers}
tag_outlier <- function(datos) {
  ifelse(datos > quantile(datos, .75) + IQR(datos) * 1.5, 
         TRUE, FALSE)
}
```

Ahora aplicamos esta función, agrupando por rareza de las cartas. Nos interesa que una carta sea excepcionalmente cara o barata con respecto al mismo tipo de carta. No tiene mucho sentido comparar los precios de No comunes con Míticas, pues estas últimas *siempre* tienen un precio más alto que las primeras.

Hacemos un `mutate()` adicional para etiquetar los outlier con el nombre de la carta, esto nos será útil más adelante (podría usar una sola llamada de `mutate()`, pero he preferido presentarlo así para hacer más claro qué está ocurriendo).

```{r tag_outliers_name}
df_dom <- 
  df_dom %>% 
  group_by(Rareza) %>% 
  mutate(Outlier = tag_outlier(Precio)) %>% 
  mutate(Outlier = ifelse(Outlier, Carta, NA))
```

Nuestro resultado es el siguiente.
```{r}
df_dom
```

Por supuesto, podemos crear otra función para llevar a cabo ese proceso.
```{r def_set_outlier}
etiquetar_outlier <- function(mtg_df) {
  mtg_df %>% 
  group_by(Rareza) %>% 
  mutate(Outlier = tag_outlier(Precio)) %>% 
  mutate(Outlier = ifelse(Outlier, Carta, NA))
}
```

El siguiente paso es explorar este set.

# Análisis  exploratorio del set
Una vez obtenidos los precios de las cartas en Dominaria, podemos visualizar cómo se distribuyen estos en general usando *ggplot2*, con un gráfico de densidad llamado con `geom_density()`.

```{r, dom_precios_densidad}
df_dom %>% 
  ggplot() +
  aes(Precio) +
  geom_density()
```

Tenemos diferencias considerables entre los precios más bajos y más altos, así que esta gráfica no nos da mucha información. 

Sin embargo, como sabemos que los precios de las cartas dependen de su rareza. Las cartas más raras tienden a ser más caras podemos visualizar los precios por rareza puede ser más útil.

Usamos la función `facet_wrap()` de *ggplot2* para generar un gráfico con las características anteriores. Usamos el argumento `scales = "free"` para que los ejes `x` y `y` sean escaladas de manera independiente.
```{r dom_precios_densidad_rap}
df_dom %>% 
  ggplot() +
  aes(Precio, fill = Precio) +
  geom_density() +
  facet_wrap(~Rareza, scales = "free")
```

Además, podemos visualizar los precios de las cartas por rareza usando diagramas de caja y bigotes (*boxplots*). La ventaja de esta visualización es que podemos etiquetar fácilemente las cartas que hemos etiquetado como *outliers* y así darnos una idea de su valor relativo.

Para lo anterior, usamos la función `geom_boxplot()` de *ggplot2* para generar la gráfica y `geom_label_repel()` de *ggrepel* para agregar etiquetas. Esta última función es una versión de `geom_label()` de *ggplot2*, que tiene ajustes para evitar que las etiquetas se superpongan, mejorando así la legibilidad. 
```{r dom_boxplot}
df_dom %>% 
  ggplot() +
  aes(Rareza, Precio, fill = Rareza) +
  geom_boxplot() +
  geom_label_repel(aes(label = Outlier), size = 2.3) +
  theme(legend.position = "none")
```

Con esto tenemos una idea general de los precios de Dominaria.

Definimos 
```{r def_explorar}
explorar_set <- function(mtg_df) {
  mtg_df %>% 
    ggplot() +
    aes(Precio, fill = Precio) +
    geom_density() +
    facet_wrap(~Rareza, scales = "free")
  
  mtg_df %>% 
    ggplot() +
    aes(Rareza, Precio, fill = Rareza) +
    geom_boxplot() +
    geom_label_repel(aes(label = Outlier), size = 2.3) +
    theme(legend.position = "none")
}
```

```{r}
df_dom %>% 
  
```


Procedemos a estimar qué tan probable es que recuperemos nuestro dinero si decidimos comprar cajas de sobres de esta expansión.

# Simulaciones
Vamos a hacer dos simulaciones, una de sobre y una de caja de sobres.

Los sets de Magic, normalmente, son vendidos en sobres que contienen 15 cartas, distribuidas de la misma manera:

* 1 cara de tierra básica.
* 10 cartas comunes.
* 3 cartas no comunes.
* 1 carta rara, o 1 carta mítica en uno de cada ocho sobres, aproximadamente.

Estos sobres, a su vez, generalmente se venden en cajas que contienen 36 sobres.

Por lo tanto, necesitamos simular el contenido de un sobre, para repetir ese ejercicio 36 veces, para así determinar el valor monetario de una caja de Magic.

Empecemos con la simulación de un sobre.

## Simulación de un sobre
Crearemos una lista con listas de pares con las rarezas de las cartas y la frecuencia con la que aparecen. Omitimos las cartas de tierra básica, pues ellas generalmente no tienen ningún valor financiero.

```{r rareza_frecuencia}
rareza_frecuencia <- list(
  list("Rare", 1),
  list("Uncommon", 3),
  list("Common", 10)
)
```

Usaremos esta lista con la función `map()` de **purrr**.

Lo que haremos dentro con esta función será filtrar de nuestro data frame con el set Dominaria, las cartas por rareza, y luego extraer una muestra de ellas igual a la frecuencia con la que aparecen.

Usaremos, en conjunto con `map()`, las funciones `filter()` y `sample_n()` de **dplyr**. Hagamos esto con `set.seed()`, para que obtengas los mismos resultados.

```{r}
set.seed(2018)

map(rareza_frecuencia, function(pareja){
  df_dom %>% 
    filter(Rareza == pareja[[1]]) %>% 
    sample_n(size = pareja[[2]])
})
```

El resultado es una lista, que representa un sobre de Magic.

Como usaremos mucho esta función anónima, es mejor que de una vez le demos nombre. La llamaremos `pareja()`.

```{r funcion_pareja}
pareja <- function(lista, datos) {
  datos %>% 
    filter(Rareza == lista[1]) %>% 
    sample_n(size = as.numeric(lista[2]))
}
```

De esta manera, podemos usar `map()` para generar sobres con una sola línea.
```{r map_con_pareja}
set.seed(2018)
map(rareza_frecuencia, pareja, datos = df_dom)
```

Como necesitamos un data frame para análisis posteriores, corremos lo anterior seguido de `reduce()` de *purrr*, que aplica una función de manera secuencial a todos los elementos de una lista. Aplicaremos `bind_rows()` de *dplyr* para obtener como resultado un data frame.

```{r map_con_pareja_reduce}
set.seed(8102)
map(rareza_frecuencia, pareja, datos = df_dom) %>% 
  reduce(bind_rows)
```

Lo anterior, sin embargo, no nos permite crear sobres con cartas míticas. Necesitamos solucionar esto.

## Las cartas míticas
Dado que las cartas míticas aparecen en un sobre una de cada ocho veces ($p = 1/8$), podemos simular este comportamiento con una distribución binomial.

Usamos la función `rbinom()`, para generar 1 y 0 al azar, teniendo el 1 una probabilidad de $1/8$ ocurrir, esto es, 12.5%  de los casos.

Pongamos esto a prueba, generando 40 números.
```{r}
rbinom(n = 40, size = 1, prob = 1/8)
```

Luce razonable.

Entonces, lo que haremos es que  es establecer una condición con `ìf`. Si la rareza de la que estamos extrayendo cartas es "Rare" y al mismo tiempo obtenemos un 1 con la distribución binomial anterior.

Lo siguiente nos devolverá una carta Rara.
```{r obtener_rara}
set.seed(6)
rareza_frecuencia %>% 
  map(function(x) {
    if(x[[1]] == "Rare" & rbinom(n = 1, size = 1, prob = 1/8)) {
      "Mythic"
    } else {
      x[[1]]
    }
  })
```

Y lo siguiente una mítica.
```{r obtener_mitica}
set.seed(7)
rareza_frecuencia %>% 
  map(function(x) {
    if(x[[1]] == "Rare" & rbinom(n = 1, size = 1, prob = 1/8)) {
      "Mythic"
    } else {
      x[[1]]
    }
  })
```

Combinamos esto con la función `pareja()` para crear sobres como data frames. Definimos una función llamada `simular_sobre()`.
```{r crear_sobre}
simular_sobre <- function(tabla) {
  rareza_frecuencia <- list(
    c("Rare", 1),
    c("Uncommon", 3),
    c("Common", 10)
  )
  
  rareza_frecuencia <- 
    map(rareza_frecuencia, function(x) {
      if(x[[1]] == "Rare" & rbinom(n = 1, size = 1, prob = 1/8)) {
        x[[1]] <- "Mythic"
      } else {
        x[[1]]
      }
      x
    })
  
  map(rareza_frecuencia, pareja, datos = tabla) %>% 
    reduce(bind_rows)
}
```

Pongamos a prueba nuestra función `simular_sobre()`.
```{r crear_sobre_probar}
set.seed(7)
simular_sobre(tabla = df_dom)
```

Con esta función, podemos crear cajas de sobres fácilmente.

## Simular caja de sobres
Usamos la función `map()` para crear 36 sobres, repitiendo ese mismo número de veces la función `simular_sobre()`.

```{r simular_caja_dom}
set.seed(8244)
caja_dom <- map(1:36, ~simular_sobre(tabla = df_dom))
```

De esta manera obtenemos una lista con 36 elementos, cada uno de ellos representando un sobre de Magic. Por ejemplo, este es el cuarto sobre.
```{r cuarta_caja_simulacion}
caja_dom[[4]]
```

Vamos a crear una función para simular una caja de Magic, que nos de como resultado un data frame con los 36 sobres.

```{r funcion_simular_caja}
simular_caja <- function(datos) {
  map(1:36, ~simular_sobre(tabla = df_dom)) %>% 
    reduce(bind_rows)
}
```

Probamos nuestra función.
```{r simulacion_caja}
set.seed(8244)
caja_dom <- simular_caja(datos = df_fom)
```

Comprobamos que hemos generado 36 cartas Raras o Míticas.
```{r test_rara_mitica}
caja_dom %>% 
  filter(Rareza %in% c("Rare", "Mythic"))
```

Para una simulación apropiada, necesitamos repetir lo anterior en múltiples ocasiones.

## Simulación de múltiples cajas
Ahora podemos calcular, en promedio, cual es el valor de una caja de Dominaria.

Usamos `map()` para repetir 100 veces la función simular caja y así obtenr esa cantidad de precios. De nuevo usamos `reduce()` para obtener como resultado un data frame.
```{r simular_cien_cajas, cache=TRUE}
set.seed(3356)

ciencajas_dom <- 
  map(1:100, function(x) {
    simular_caja(datos = df_dom) %>% 
      summarize(Valor = sum(Precio))
  }) %>% 
  reduce(bind_rows)
```

Como anteriormente dejamos agrupados nuestros datos por rareza, obtendremos un data frame con cerca de 400 renglones, uno por rareza de cada caja de Magic simulada. No siempre será 400, pues hay una probabilidad de que una desafortunada caja no tenga ni una sola carta Mítica.
```{r resultado_cien_cajas}
ciencajas_dom
```

De esta manera podemos otener el valor promedio por rareza de las cartas.
```{r media_por_rareza}
ciencajas_dom %>% 
  group_by(Rareza) %>% 
  summarize(Promedio = mean(Valor))
```

Sin embargo, necesitamos hacer un pequeño ajuste. 

Necesitamos proporcionar un identificador para caja, para así poder obtener un valor total por caja y, con ello, el valor promedio por caja.

Hagamos el cambio y de una vez definamos una función llamada `simular_ciencajas()`, aunque en realidad, podremos definir el número de iteraciones que deseemos, no sólo 100.
```{r def_simular_ciencajas}
simular_ciencajas <- function(datos, iteraciones = 100) {
  map(1:iteraciones, function(num_caja) {
    simular_caja(datos = datos) %>% 
      summarize(Valor = sum(Precio)) %>% 
      mutate(Id_caja = num_caja)
  }) %>% 
  reduce(bind_rows)
}
```

Pongamos a prueba nuestra función.
```{r test_simular_ciencajas, cache=TRUE}
set.seed(3356)

ciencajas_dom <- simular_ciencajas(datos = df_dom)
```

Nuestro resultado es muy similar al anterior, sólo que ahora tenemos identificador por caja.
```{r resultado_simular_ciencajas}
ciencajas_dom
```

Con este identificador podemos obtener el valor promedio de una caja de sobres de Dominaria .
```{r promedio_simular_ciencajas}
ciencajas_dom %>% 
  group_by(Id_caja) %>% 
  summarize(Suma = sum(Valor)) %>% 
  summarize(Media = mean(Suma))
```

La cosa marcha bien, pero nos falta considerar una característica del valor de una caja de Magic: las cartas comunes tiene poca "liquidez". Aunque nominalmente pueden tener algún valor, a menos que sea una carta de alta demanda, lo cual es reflejado en su precio, es un poco más difícil venderlas y recuperar lo invertido en obtenerlas

Esto es, las cartas comunes que más fácilmente pueden venderse, son las más caras. Por suerte ya las hemos etiquetado con nuestra función  `tag_outlier()`.

Así que vamos a obtener la media de valor de una caja, excluyendo las cartas comunes que no tienen un Precio particularmente alto.
```{r simular_ciencajas_no_comunes, cache=TRUE}
simular_ciencajas <- function(datos, iteraciones = 100) {
  map(1:iteraciones, function(num_caja) {
    simular_caja(datos = datos) %>% 
      filter(Rareza != "Common" | (Rareza == "Common" & !is.na(Outlier)) ) %>% 
      summarize(Valor = sum(Precio)) %>% 
      mutate(Id_caja = num_caja)
  }) %>% 
  reduce(bind_rows)
}

set.seed(3356)
ciencajas_dom <- simular_ciencajas(datos = df_dom)

ciencajas_dom

ciencajas_dom %>% 
  group_by(Id_caja) %>% 
  summarize(Suma = sum(Valor)) %>% 
  summarize(Media = median(Suma))
```

# Probabilidad de recuperar inversión
Después de simular el valor de múltiples cajas de sobres de Magic, podemos calcular la probabilidad de recuperar lo que hemos invertido en una de ellas.

Para lograr esto, necesitamos calcular la función de densidad de los valores de las cajas simuladas.

Primero, obtenemos el valor de cada caja, agrupando los Precios de las cartas en ellas por **Id_caja**. Una vez que hemos obtenido estos valores, los extraemos como un vector con la función `pull()` de *dplyr*.
```{r valorcajas_dom}
valorcajas_dom <- 
  ciencajas_dom %>% 
  group_by(Id_caja) %>% 
  summarize(Suma = sum(Valor)) %>% 
  pull(Suma)
```

Este es nuestro resultado.
```{r valorcajas_dom_mostrar}
valorcajas_dom
```

Definamos una función que realice lo anterior.
```{r definir_valor_cajas}
valor_cajas <- function(cajas_simuladas) {
  cajas_simuladas %>% 
    group_by(Id_caja) %>% 
    summarize(Suma = sum(Valor)) %>% 
    pull(Suma)
}
```

Usamos `density()` en nuestro vector anterior para obtener la función de densidad de estos valores.
```{r densidad_dom}
densidad_dom <- density(valorcajas_dom)
```

Obtenemos lo siguiente.
```{r mostrar_densidad_dom}
densidad_dom
```

Si deseamos obtener una gráfica de esta función usando `ggplot()` y `geom_area()` de *ggplot2*. Pero antes necesitamos extraer la información de los ejes `x` y `y`, y después convertir eso a un data frame con `tbl_df()`.
```{r densidad_plot}
densidad_dom[c("x", "y")] %>% 
  tbl_df() %>%
  ggplot() +
  aes(x, y) +
  geom_area()
```

Con esto obtenemos un área bajo una curva. Esta área representa, aproximadamente, una distribución de todos los valores que podrían tomar las cajas de sobres Magic, a partir de la simulación que hemos realizado. Es el 100% de los casos.

Podemos trazar una línea vertical que divida esta área bajo la curva en dos, justo en el valor de nuestra mediana: 104. Si hacemos esto, tendremos dos segmentos del área, uno con 50% de los valores por debajo de 104 (área a la izquierda) y 50% con los valores por encima de este valor (área a la derecha). 

Como esta es una representación de una distribución, lo anterior quiere decir que si sacamos un valor al azar de esta distribución, tenemos 50% de probabilidad de que sea menor a 104 y 50% de probabilidad que sea mayor.

Veamos como luce lo anterior
```{r densidad_plot_segmentos}
densidad_dom[c("x", "y")] %>% 
  tbl_df() %>%
  ggplot() +
  aes(x, y) +
  geom_area() +
  geom_vline(xintercept = 104, color = "red")
```

Por lo tanto, si queremos calcular la probabilidad de que recuperemos nuestra inversión al comprar una caja de sobres de Magic, lo único que tenemos que hacer es calcular el área que resulta de segmentar nuestra distribución en dos. 
Para calcular esta área, usamos las funciones `approxfun()` e `integrate()`. 

Como su nombre lo indica, la función `integrate()` usará integración para calcular un área, por lo que nos pedirá un límite inferior y uno superior. 

Supongamos que que hemos comprado una caja de sobres de Dominaria en 100 dólares. Usaremos este valor como límite inferior y el valor máximo de nuestra distribución como límite superior.
```{r integrar}
densidad_dom %>% 
  approxfun() %>% 
  integrate(upper = max(valorcajas_dom), lower = 100)
```

¡Perfecto!
  
Lo que hemos obtenido es la probabilidad de que recuperemos nuestra inversión, esto es decir, hay 54.75% de probabilidad de comprar una caja y que esta tenga un valor mayor que 100 USD.

En este caso es más o menos lanzar una moneda al aire recuperar nuestra inversión si pagamos 100 USD por una caja de Dominaria.

Vamos a convertir a lo anterior a funciones.


Primero, una función que calcule la función de densidad, la probabilidad a partir de un costo que elijamos, y el data frame de la función de densidad.

Además, aprovecharemos para etiquetar los valor en el data frame de la función de densidad como menores o mayores al costo elegido.
```{r def_magic_densidad}
magic_densidad <- function(valor_cajas, costo_pagado) {
  magic <- list()
  
  magic$costo_pagado <- costo_pagado
  
  magic$densidad <- 
    density(valor_cajas)
  
  magic$probabilidad <- 
    magic$densidad %>% 
    approxfun() %>% 
    integrate(upper = max(valor_cajas), lower = costo_pagado)
  
  magic$df_densidad <- 
    magic$densidad[c("x", "y")] %>% 
    tbl_df() %>% 
    mutate(Tipo = ifelse(x < costo_pagado, "Menor", "Mayor"))
  
  magic
}
```

El resultado será una lista con cuatro elementos: el costo pagado, la función de densidad, probabilidad y un data frame.

```{r test_magic_densidad}
magic_densidad(valorcajas_dom, costo_pagado = 100)
```

Ahora, creamos una función que use esta lista para generar un gráfico.

```{r def_plot_densidad}
plot_densidad <- function(lista_densidad) {
  
  label_costo <- 
    paste0("Costo pagado: ", lista_densidad$costo_pagado, " USD")

  label_prob <- 
    paste0("Probabilidad de recuperar inversión: ", 
           round(lista_densidad$probabilidad$value, 4) * 100, 
           "%")
  
  
 lista_densidad$df_densidad %>% 
     ggplot() +
     aes(x, y, fill = Tipo) +
     geom_area() +
     labs(title =  paste0(label_costo, "\n", label_prob))
}
```

Hecho esto, podemos probar con otros costos de una caja de Dominaria. Por ejemplo, si pagamos 90 USD, naturalmente nos irá mejor.
```{r test_plot_densidad}
 magic_densidad(valorcajas_dom, 90) %>% 
   plot_densidad()
```

```{r, cache = TRUE}
top_kek <- leer_html("goldfish_M19.html")

top_kek <- etiquetar_outlier(top_kek)

explorar_set(top_kek)

set.seed(25)
top_cien <- simular_ciencajas(top_kek)

top_valor <- valor_cajas(top_cien)

top_densidad <- magic_densidad(top_valor, costo_pagado = 90)

plot_densidad(top_densidad)
```




```{r}
lsf.str()
```

